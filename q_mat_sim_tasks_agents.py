# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QMatSim
                                 A QGIS plugin
 QGIS to MatSim
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-07
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Dmitry D.
        email                : dmitrdobr@mail.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import pyqtSignal, QTime

from qgis.core import (
      QgsVectorLayer, 
      QgsGeometry,
      QgsFeature, 
      QgsFeatureIterator, 
      QgsPointXY, 
      QgsTask,
      QgsField,
      QgsFields,
      QgsWkbTypes,
      QgsFeatureRequest,
      QgsRectangle, 
      QgsVector,
      QgsExpression
)

from qgis.PyQt import QtXml

import numpy as np
import heapq, random

from datetime import datetime, time, timedelta

POINT_NODE_XML_TASK_DESCRIPTION = "POINT_NODE_XML_TASK"
LINE_LINK_XML_TASK_DESCRIPTION = "LINE_LINK_XML_TASK"
LINE_LINK_NMP_TASK_DESCRIPTION = "LINE_LINK_ARRAY_TASK"
AGENT_XML_TASK_DESCRIPTION = "AGENT_XML_TASK"

class XmlBaseV2(): # Base to quickly create XML elements
      def __init__(self, doc, startDomName):
            self.__doc = doc # QDomDocument()
            self.DomElementStack = list()

            self.rootDom = self.__doc.elementsByTagName(startDomName).item(0) # QDomElement
      
      def applyToRootDom(self): # set element at the end of stack as child for root element
            print(len(self.DomElementStack))
            for el in self.DomElementStack:
                  self.rootDom.appendChild(el)
            # self.rootDom.appendChild(self.DomElementStack[0])
      
      def createDomAtStack(self, domName: str): # create new element at the end of stack
            elem = self.__doc.createElement(domName)
            self.DomElementStack.append(elem)
      
      def addAttributesAtLastDomAtStack(self, params: dict): # add attributes to element at the end of stack
            for key, value in params.items():
                  self.DomElementStack[-1].setAttribute(key, str(value))

      def addTextNodeToLastDomAtStack(self, text: str): # insert text to element at the end of stack
            tx = self.__doc.createTextNode(text)
            self.DomElementStack[-1].appendChild(tx)

      def appendLastDomAtStack(self): # set element at the end of stack as child for element before and delete it from stack
            self.DomElementStack[-2].appendChild(self.DomElementStack[-1])
            self.DomElementStack.pop()

      def printDoc(self):
            print(self.__doc.toString())

class ActData(): # DataClass for act params
      def __init__(self, acttype, actTime, actTimeOp):
            self.type = acttype
            self.point = None # QgsGeometry
            self.link = -1
            self.time = actTime # QTime
            self.timeOperation = actTimeOp # str 'end_time'
      
      def setLink(self, link):
            self.link = link
      
      def setPoint(self, geom: QgsGeometry):
            self.point = geom.asPoint()
      
      def getActParams(self):
            params = dict()
            params['type'] = self.type
            params['x'] = self.point.x()
            params['y'] = self.point.y()
            params['link'] = self.link
            params[self.timeOperation] = self.time.toString()

            return params
      def __str__(self):
            string =  ' - act info: \n'
            string += '   - type: ' + str(self.type) + '\n'
            string += '   - x: ' + str(round(self.point.x(),3)) + ' y: ' + str(round(self.point.y(),3)) + '\n'
            string += '   - link: ' + str(self.link) + '\n'
            string += '   - ' + str(self.timeOperation) + ' ' + self.time.toString()

            return string

      def renderAsXml(self):
            print(f'<act type="{self.type}" x="{str(round(self.point.x(),3))}" y="{str(round(self.point.y(),3))}" link="{self.link}" {self.timeOperation}="{self.time.toString()}"/>')


class AgentXmlTask(XmlBaseV2, QgsTask):
      printLog = pyqtSignal(str)
      
      def __init__(self, document, nodesLayer, actsLayer, matrix, taskSettings):
            XmlBaseV2.__init__(self, doc=document, startDomName="plans") # append final <person> element to <plans> root element
            QgsTask.__init__(self, AGENT_XML_TASK_DESCRIPTION, QgsTask.CanCancel)

            self.agCount = taskSettings['AgentsCount']
            self.settings = taskSettings

            self.actsLayer = actsLayer
            self.nodesLayer = nodesLayer

            self.filterActPointsID = list([-1]) # id of point at acts layer for previous act when creating acts

      def run(self):
            for i in range(1, self.agCount+1):
                  # reset ids filter to acts
                  self.filterActPointsID.clear()
                  self.filterActPointsID.append(-1)

                  if self.isCanceled():
                        return False
                  
                  # new person node
                  self.createDomAtStack('person')
                  self.addAttributesAtLastDomAtStack(dict({'id': str(i)}))
                  
                  # random act count
                  actCount = random.randint(self.settings['ActCountMin'], self.settings['ActCountMax']) # random count of acts
                  print('agent no ' , i , ' act count: ' , actCount)

                  # if last act is first do -1
                  if (self.settings['LastFirstAct']):
                        actCount -= 1

                  acts = self.createActs(actCount) # list of acts DataClass

                  for a in acts:
                        a.renderAsXml()

                  self.setProgress(int(i/(self.agCount+1)))
            
            self.setProgress(100)
            return True

      def createActs(self, actCount): # cycle to create list of acts
            acts = list()

            firstAct = None
            if (self.settings['FirstActHome']): # if first act if h - use filter
                  firstAct = self.generateAct(filterActType='h', isFirst=True)
            else:
                  firstAct = self.generateAct(isFirst=True)

            acts.append(firstAct) # add first act
            firstActId = self.filterActPointsID[0] # remember first act feature id to not repeat at last
            
            for i in range(1, actCount): # other acts
                  if (i==actCount - 1):
                        self.filterActPointsID.append(firstActId)
                  acts.append(self.generateAct())
            
            if (self.settings['LastFirstAct']): # if first act equals last - add firstAct
                  acts.append(firstAct)

            return acts

      def generateAct(self, filterActType=None, isFirst = False): # generate random act

            ids = list()
            features = None
            # get random feature id on filter of act type or from whole layer
            if (filterActType):
                  string = f'"acttype"=\'{filterActType}\'' # request string
                  request = QgsFeatureRequest(QgsExpression(string))

                  features = self.actsLayer.getFeatures(request)
            else:
                  features = self.actsLayer.getFeatures()

            for f in features:
                  if (f.id() not in self.filterActPointsID):
                        ids.append(f.id())

            FeatureId = random.choice(ids) # random from ids
            self.prevActPointId = FeatureId # use in next iteration to not use one point two times
            self.filterActPointsID[0] = FeatureId

            actFeature = self.actsLayer.getFeature(FeatureId) # get act feature
            actTimeVal = None
            actTimeOperation = None
            if (isFirst):
                  actTimeOperation = 'end_time'
                  actTimeVal = self.randTimeFromSecLimit(self.settings['FirstActMinMax'])
            else:
                  actTimeOperation = 'dur'
                  actTimeVal = self.randTimeFromSecLimit(self.settings['ActMinMaxTime'].get(actFeature.attribute('acttype')))

            act = ActData(actFeature.attribute('acttype'), actTimeVal, actTimeOperation)
            act.setPoint(actFeature.geometry())

            return act

      def randActPointFeature(self, filterType=None): # get random act point from acts layer if filterType is set, get with current act type
            FeatureId = -1

            if (filterType):
                  string = f'"acttype"=\'{filterType}\'' # request string
                  request = QgsFeatureRequest(QgsExpression(string))
                  ids = list()
                  for f in self.actsLayer.getFeatures(request): # request features and get theirs $id
                        ids.append(f.id())
                  FeatureId = random.choice(ids) # random from ids
            else:
                  FeatureId = random.randint(1,self.actsLayer.featureCount())

            return self.actsLayer.getFeature(FeatureId)

      def randTimeFromSecLimit(self, MinMaxList):
            val = random.randint(MinMaxList[0], MinMaxList[1])
            t = QTime(0,0)
            t = t.addSecs(val)
            return t

      def finished(self, result):
            
            self.applyToRootDom()
            self.printDoc()

            self.printLog.emit(f'[INFO]:[{self.description()}] => Task finished.')
            self.result = result
    
      def cancel(self):
            self.printLog.emit(f'[INFO]:[{self.description()}] => Task cancel.')
            super().cancel()
