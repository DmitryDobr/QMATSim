# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QMatSim
                                 A QGIS plugin
 QGIS to MatSim
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2024-10-07
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Dmitry D.
        email                : dmitrdobr@mail.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

from qgis.PyQt.QtCore import pyqtSignal, QTime

from qgis.core import (
      QgsVectorLayer, 
      QgsGeometry,
      QgsFeature, 
      QgsFeatureIterator, 
      QgsPointXY, 
      QgsTask,
      QgsField,
      QgsFields,
      QgsWkbTypes,
      QgsFeatureRequest,
      QgsRectangle, 
      QgsVector,
      QgsExpression
)

from qgis.PyQt import QtXml

import numpy as np
import heapq, random

from datetime import datetime, time, timedelta

AGENT_XML_TASK_DESCRIPTION = "AGENT_XML_TASK"

class XmlBaseV2(): # Base to quickly create XML elements
      def __init__(self, doc, startDomName):
            self.__doc = doc # QDomDocument()
            self.DomElementStack = list()

            self.rootDom = self.__doc.elementsByTagName(startDomName).item(0) # QDomElement
      
      def applyToRootDom(self): # set element at the end of stack as child for root element
            for el in self.DomElementStack:
                  self.rootDom.appendChild(el)
            # self.rootDom.appendChild(self.DomElementStack[0])
      
      def createDomAtStack(self, domName: str): # create new element at the end of stack
            elem = self.__doc.createElement(domName)
            self.DomElementStack.append(elem)
      
      def addAttributesAtLastDomAtStack(self, params: dict): # add attributes to element at the end of stack
            for key, value in params.items():
                  self.DomElementStack[-1].setAttribute(key, str(value))

      def addTextNodeToLastDomAtStack(self, text: str): # insert text to element at the end of stack
            tx = self.__doc.createTextNode(text)
            self.DomElementStack[-1].appendChild(tx)

      def appendLastDomAtStack(self, count=1): # set element at the end of stack as child for element before and delete it from stack
            for i in range(0, count):
                  self.DomElementStack[-2].appendChild(self.DomElementStack[-1])
                  self.DomElementStack.pop()

class ActData(): # DataClass for act params
      def __init__(self, acttype, actTime, actTimeOp, actPointID):
            self.type = acttype
            self.point = None # QgsGeometry
            self.link = -1
            self.time = actTime # QTime
            self.timeOperation = actTimeOp # str 'end_time'
            self.actPointID = actPointID
      
      def setLink(self, link):
            self.link = link
      
      def setPoint(self, geom: QgsGeometry):
            self.point = geom.asPoint()
      
      def getActParams(self, isLast = False):
            params = dict()
            params['type'] = self.type
            params['x'] = round(self.point.x(),3)
            params['y'] = round(self.point.y(),3)
            params['link'] = self.link
            if (not isLast):
                  params[self.timeOperation] = self.time.toString()

            return params
      
      def __str__(self):
            string =  ' - act info: \n'
            string += '   - type: ' + str(self.type) + '\n'
            string += '   - x: ' + str(round(self.point.x(),3)) + ' y: ' + str(round(self.point.y(),3)) + '\n'
            string += '   - link: ' + str(self.link) + '\n'
            string += '   - ' + str(self.timeOperation) + ' ' + self.time.toString()

            return string


class AgentXmlTask(XmlBaseV2, QgsTask):
      printLog = pyqtSignal(str)
      
      def __init__(self, document, nodesLayer, actsLayer, matrix, AgentTaskSettings, NetWorkSettings):
            XmlBaseV2.__init__(self, doc=document, startDomName="plans") # append final <person> element to <plans> root element
            QgsTask.__init__(self, AGENT_XML_TASK_DESCRIPTION, QgsTask.CanCancel)

            self.agCount = AgentTaskSettings['AgentsCount']
            self.AgentSettings = AgentTaskSettings
            self.networkSettings = NetWorkSettings

            self.actsLayer = actsLayer
            self.nodesLayer = nodesLayer

            self.networkMatrix = matrix

            self.filterActPointsID = list([-1]) # id of point at acts layer for previous act when creating acts

            self.ActToNodeNearPointIDs = dict() # paired $id/.id() of points at Acts and Nodes Layers for nearest points
            # fill the dict
            for actFeature in self.actsLayer.getFeatures():
                  nearNodeID = -1
                  minDist = -1

                  for nodeFeature in self.nodesLayer.getFeatures():
                        newDist = actFeature.geometry().distance(nodeFeature.geometry())

                        if minDist < 0 or newDist < minDist:
                              minDist = newDist
                              nearNodeID = nodeFeature.id()

                  self.ActToNodeNearPointIDs[actFeature.id()] = nearNodeID - 1

      def a_star_shortest_path(self, start_node, end_node): # simple a-star with no range based on length of path
            num_nodes = self.networkMatrix.shape[0]

            def heuristic(node):
                  return 0

            # initialize
            open_set = [(0, start_node)]  # (f_score, node)
            came_from = {}
            g_score = {node: float('inf') for node in range(num_nodes)}
            g_score[start_node] = 0
            f_score = {node: float('inf') for node in range(num_nodes)}
            f_score[start_node] = heuristic(start_node)

            while open_set:
                  current_f, current_node = heapq.heappop(open_set)

                  if current_node == end_node:
                        path = []
                        while current_node in came_from:
                              path.append(current_node)
                              current_node = came_from[current_node]
                        path.append(start_node)
                        return path[::-1]  # reversed route

                  neighbors = np.where(self.networkMatrix[current_node] > 0)[0]  # Effective neighbours finding

                  for neighbor in neighbors:
                        tentative_g_score = g_score[current_node] + 1
                        if tentative_g_score < g_score[neighbor]:
                              came_from[neighbor] = current_node
                              g_score[neighbor] = tentative_g_score
                              f_score[neighbor] = tentative_g_score + heuristic(neighbor)
                              heapq.heappush(open_set, (f_score[neighbor], neighbor))

            return None  # No route

      def run(self):
            for i in range(1, self.agCount+1):
                  # reset ids filter to acts
                  self.filterActPointsID.clear()
                  self.filterActPointsID.append(-1)

                  if self.isCanceled():
                        return False
                  
                  # new person node
                  self.createDomAtStack('person')
                  self.addAttributesAtLastDomAtStack(dict({'id': str(i)}))
                  
                  # random act count
                  actCount = random.randint(self.AgentSettings['ActCountMin'], self.AgentSettings['ActCountMax']) # random count of acts
                  self.printLog.emit(f'[ERROR]:[{self.description()}] => Agent no ({i}). Acts count: {actCount}.')

                  self.createDomAtStack('plan')

                  # if last act is first do -1
                  if (self.AgentSettings['LastFirstAct']):
                        actCount -= 1

                  acts = self.createActs(actCount) # list of acts DataClass

                  for j in range(0, len(acts)): # for every generated act
                        flag = (j == len(acts) - 1)

                        # add act DOM
                        self.createDomAtStack('act')
                        self.addAttributesAtLastDomAtStack(acts[j].getActParams(isLast = flag ))

                        # add leg DOM
                        if (not flag):

                              routeResult = self.defineRouteBetweenActs(acts[j], acts[j+1])
                              if (not routeResult):
                                    self.printLog.emit(f'[ERROR]:[{self.description()}] => Agent no ({i}). Route between acts {j} and {j+1} not found.')
                                    return False

                              self.addAttributesAtLastDomAtStack(acts[j].getActParams(isLast = flag )) # add act attributes to current act from act DataClass
                              self.appendLastDomAtStack() # add act to plan DOM
                              
                              self.createDomAtStack('leg') # create leg DOM
                              self.addAttributesAtLastDomAtStack(dict({'mode': 'car'})) # add mode attribute (update in future to other modes)
                              self.createDomAtStack('route') # add route DOM

                              if (len(routeResult) > 1):
                                    string = " ".join(str(el) for el in routeResult)
                                    self.addTextNodeToLastDomAtStack(string) # add route nodes ids as text
                              else:
                                    self.addTextNodeToLastDomAtStack(' ') # if path consist one point => no need to write route
                                    self.printLog.emit(f'[WARN]:[{self.description()}] => Agent no ({i}). Route between acts {j} and {j+1} consists less then 3 points')

                              self.appendLastDomAtStack(2) # route to leg; leg to plan <plan> -> <leg> -> <route>
                        else:
                              self.addAttributesAtLastDomAtStack(acts[j].getActParams(isLast = flag ))
                              self.appendLastDomAtStack() # append last act at plan to plan DOM
                        
                  self.appendLastDomAtStack() # append plan at person

                  self.setProgress(int(i/(self.agCount+1)))
                  self.printLog.emit(f'[ERROR]:[{self.description()}] => Agent no ({i}). Done generation.')
            
            self.setProgress(100)
            return True

      def defineRouteBetweenActs(self, act, nextAct): # define route and fill link numbers for given acts. return false if route not generated
            path = self.a_star_shortest_path(self.ActToNodeNearPointIDs[act.actPointID], self.ActToNodeNearPointIDs[nextAct.actPointID])
            if (not path):
                  return False

            if (len(path) > 1): # if route have 2+ points
                  if (act.link == -1):
                        act.setLink(self.networkMatrix[path[0], path[1]])
                  nextAct.setLink(self.networkMatrix[path[-2], path[-1]]) # next act have link that connects 2 last points of route
            else: # if route have 1 point (possible when 2 acts have 1 nearest node point)
                  if (act.link == -1): # if it is first act => find first link that connects point nearest to act and some other point 
                        linkNum = -1
                        for i in range(0, self.networkMatrix.shape[0]):
                              if (self.networkMatrix[path[0], i] >= 0):
                                    linkNum = self.networkMatrix[path[0], i]
                                    break
                        act.setLink(linkNum) # set link for current act
                  nextAct.setLink(act.link) # next act after leg have similar link number that current act
            
            if (not self.networkSettings['IdValOnLayer']):
                  for i in range(0, len(path)):
                        path[i] = int(self.nodesLayer.getFeature(path[i]+1).attribute(self.networkSettings['PointAttr']))
            else:
                  for i in range(0, len(path)):
                        path[i] += 1 # cause in Qgis .id() starts with 1 but in numpy and programming first element is 0

            return path

      def createActs(self, actCount): # cycle to create list of acts
            acts = list()

            firstAct = None
            if (self.AgentSettings['FirstActHome']): # if first act if h - use filter
                  firstAct = self.generateAct(filterActType='h', isFirst=True)
            else:
                  firstAct = self.generateAct(isFirst=True)

            acts.append(firstAct) # add first act
            firstActId = self.filterActPointsID[0] # remember first act feature id to not repeat at last
            
            for i in range(1, actCount): # other acts
                  if (i==actCount - 1):
                        self.filterActPointsID.append(firstActId)
                  acts.append(self.generateAct())
            
            if (self.AgentSettings['LastFirstAct']): # if first act equals last - add firstAct
                  acts.append(firstAct)

            return acts

      def generateAct(self, filterActType=None, isFirst = False): # generate random act

            ids = list()
            features = None
            # get random feature id on filter of act type or from whole layer
            if (filterActType):
                  string = f'"acttype"=\'{filterActType}\'' # request string
                  request = QgsFeatureRequest(QgsExpression(string))
                  features = self.actsLayer.getFeatures(request)
            else:
                  features = self.actsLayer.getFeatures()

            for f in features:
                  if (f.id() not in self.filterActPointsID):
                        ids.append(f.id())

            FeatureId = random.choice(ids) # random from ids
            self.prevActPointId = FeatureId # use in next iteration to not use one point two times
            self.filterActPointsID[0] = FeatureId

            actFeature = self.actsLayer.getFeature(FeatureId) # get act feature
            actTimeVal = None
            actTimeOperation = None
            if (isFirst):
                  actTimeOperation = 'end_time'
                  actTimeVal = self.randTimeFromSecLimit(self.AgentSettings['FirstActMinMax'])
            else:
                  actTimeOperation = 'dur'
                  actTimeVal = self.randTimeFromSecLimit(self.AgentSettings['ActMinMaxTime'].get(actFeature.attribute('acttype')))

            act = ActData(actFeature.attribute('acttype'), actTimeVal, actTimeOperation, FeatureId)
            act.setPoint(actFeature.geometry())

            return act

      def randActPointFeature(self, filterType=None): # get random act point from acts layer if filterType is set, get with current act type
            FeatureId = -1

            if (filterType):
                  string = f'"acttype"=\'{filterType}\'' # request string
                  request = QgsFeatureRequest(QgsExpression(string))
                  ids = list()
                  for f in self.actsLayer.getFeatures(request): # request features and get theirs $id
                        ids.append(f.id())
                  FeatureId = random.choice(ids) # random from ids
            else:
                  FeatureId = random.randint(1,self.actsLayer.featureCount())

            return self.actsLayer.getFeature(FeatureId)

      def randTimeFromSecLimit(self, MinMaxList): # random time value in seconds from list with [min,max]
            val = random.randint(MinMaxList[0], MinMaxList[1])
            t = QTime(0,0)
            t = t.addSecs(val)
            return t

      def finished(self, result):
            self.applyToRootDom()

            self.printLog.emit(f'[INFO]:[{self.description()}] => Task finished.')
            self.result = result
    
      def cancel(self):
            self.printLog.emit(f'[INFO]:[{self.description()}] => Task cancel.')
            super().cancel()
