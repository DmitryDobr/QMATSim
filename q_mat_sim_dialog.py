# -*- coding: utf-8 -*-
"""
/***************************************************************************
 QMatSimDialog
                                 A QGIS plugin
 QGIS to MatSim
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-10-07
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Dmitry D.
        email                : dmitrdobr@mail.ru
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import (
    QgsRasterLayer,
    QgsMapLayerProxyModel,
)

# from qgis.PyQt import QtXml
from qgis.PyQt.QtGui import QTextCursor, QSyntaxHighlighter, QFont, QTextCharFormat, QColor
from qgis.PyQt.QtCore import Qt, QRegularExpression, QRegularExpressionMatchIterator, QObject, QRegExp, QFile, QTextStream

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'q_mat_sim_dialog_base.ui'))

# import xml.etree.ElementTree as ET
# from xml.dom import minidom
# import xml.etree as etr

class HighlightingRule():
    def __init__(self, expression, format):
        self.pattern = expression
        self.format = format

class Highlighter(QSyntaxHighlighter):
    def __init__(self, parent):
        super().__init__(parent)
        self.HighlightRules: list[HighlightingRule] = [] # HighlightingRule

        classFormat = QTextCharFormat()
        classFormat.setForeground(QColor("#4452ff"))
        rule = HighlightingRule(expression=QRegularExpression(r".*"), format=classFormat)
        self.HighlightRules.append(rule)

        classFormat = QTextCharFormat()
        classFormat.setForeground(QColor("#ff3038"))
        rule = HighlightingRule(expression=QRegularExpression(r"\S+(?=\=)"), format=classFormat)
        self.HighlightRules.append(rule)

        classFormat = QTextCharFormat()
        classFormat.setForeground(QColor("#8800ff"))
        rule = HighlightingRule(expression=QRegularExpression(r'=\"([^"]*)\"'), format=classFormat)
        self.HighlightRules.append(rule)

        classFormat = QTextCharFormat()
        classFormat.setForeground(QColor("#505050"))
        rule = HighlightingRule(expression=QRegularExpression(r'='), format=classFormat)
        self.HighlightRules.append(rule)

        classFormat = QTextCharFormat()
        classFormat.setForeground(QColor("#ff3038"))
        classFormat.setBackground(QColor("#ffff00"))
        rule = HighlightingRule(expression=QRegularExpression(r"\<\?|\?>"), format=classFormat)
        self.HighlightRules.append(rule)
    
    def highlightBlock(self, text):
        for rule in self.HighlightRules:
            mIterator = rule.pattern.globalMatch(text)
            while (mIterator.hasNext()):
                match = mIterator.next()
                self.setFormat(match.capturedStart(), match.capturedLength(), rule.format)
        self.setCurrentBlockState(0)


class QMatSimDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(QMatSimDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect

        self.setupUi(self)
        self.tabWidget_base.setCurrentIndex(0)
        self.stackedWidget.setCurrentWidget(self.stackedWidgetPage1)
        # self.textEdit_help.clear()
        # document = self.textEdit_help.document()
        # cursor = QTextCursor(document)
        # p1 = cursor.position() # returns int
        # cursor.insertImage(os.path.dirname(__file__) + '/icon_small.png')
        # cursor.insertImage(os.path.dirname(__file__) + '/network_small.png')

        self.mMapLayerComboBox_links.setFilters(QgsMapLayerProxyModel.LineLayer)
        self.mMapLayerComboBox_nodes.setFilters(QgsMapLayerProxyModel.PointLayer)

        self.hl = Highlighter(self.textEdit_xmlOutput.document())

        self.pushButton_settings.clicked.connect(self.changeWidgetSettings)
        self.pushButton_settingsCancel.clicked.connect(self.changeWidgetSettings)
        self.pushButton_settingsOk.clicked.connect(self.saveSettings)

        self.mMapLayerComboBox_links.layerChanged.connect(self.mFieldComboBox_Oneway.setLayer)
        self.mMapLayerComboBox_links.layerChanged.connect(self.mFieldComboBox_LineAttrId.setLayer)
        self.mMapLayerComboBox_nodes.layerChanged.connect(self.mFieldComboBox_PointAttrId.setLayer)

        self.mFieldComboBox_Oneway.setLayer(self.mMapLayerComboBox_links.currentLayer())
        self.mFieldComboBox_LineAttrId.setLayer(self.mMapLayerComboBox_links.currentLayer())
        self.mFieldComboBox_PointAttrId.setLayer(self.mMapLayerComboBox_nodes.currentLayer())

        self.radioButton_2sided_2.toggled.connect(self.setOneWaySettingsEnabled)

        self.taskSettings = dict() # settings for XML tasks
        self.reloadSettings()

        f = QFile(os.path.dirname(__file__) + "/help.html")
        f.open(QFile.ReadOnly|QFile.Text)
        istream = QTextStream(f)
        self.textEdit_help.insertHtml(istream.readAll())
        f.close()

        document = self.textEdit_help.document()
        cursor = QTextCursor(document)

        cursor.movePosition(QTextCursor.Start, QTextCursor.MoveAnchor,1)
        self.textEdit_help.setTextCursor(cursor)


    def addLogMessage(self, string): # insert log message to log textedit
        self.textEdit_log.append(string)

    def changeWidgetSettings(self): # set widget page
        if self.stackedWidget.currentWidget() == self.stackedWidgetPage2:
            self.stackedWidget.setCurrentWidget(self.stackedWidgetPage1)
        else:
            self.stackedWidget.setCurrentWidget(self.stackedWidgetPage2)

    def saveSettings(self): # save settings for tasks and get back to main page
        self.stackedWidget.setCurrentWidget(self.stackedWidgetPage1)
        self.reloadSettings()

    def reloadSettings(self): # reload settings for tasks
        self.taskSettings['AllLine2Sides'] = self.radioButton_2sided.isChecked() # define that all lines need to have copy with different way
        self.taskSettings['Attribute'] = self.mFieldComboBox_Oneway.currentField() # on what attribute to know is line is oneway or 2-sided
        self.taskSettings['OneWayVal'] = self.lineEdit_oneway.text() # what value of attribute defines oneway lines
        self.taskSettings['TwoSidedVal'] = self.lineEdit_twoSide.text() # what value of attribute defines two-sided lines
        self.taskSettings['DefaultTwoWay'] = self.comboBox_direction.currentIndex() # is default status of line is two-sided

        self.taskSettings['IdValOnLayer'] = self.radioButton_idVal1.isChecked() # using $id to identify features or use attribute
        self.taskSettings['PointAttr'] = self.mFieldComboBox_PointAttrId.currentField() # what attribute for points to set id
        self.taskSettings['LineAttr'] = self.mFieldComboBox_LineAttrId.currentField() # what attribute for lines to set id
    
    def getSettings(self): # get settings for tasks
        return self.taskSettings

    def setOneWaySettingsEnabled(self, flag): # enable oneway settings widgets
        self.mFieldComboBox_Oneway.setEnabled(flag)
        self.lineEdit_oneway.setEnabled(flag)
        self.lineEdit_twoSide.setEnabled(flag)
        self.comboBox_direction.setEnabled(flag)

    def resetGUI(self): # reset widgets displays
        self.textEdit_xmlOutput.clear()
        self.textEdit_log.clear()
        self.tabWidget_xml.setCurrentWidget(self.tab_output)
        self.progressBar.setValue(0)
        self.pushButton_saveFile.setEnabled(False)
